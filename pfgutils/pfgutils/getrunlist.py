#!/usr/bin/env python

# This script prints (and saves it to runs.list) runs from CMS Online DQM for the latest N days.
#   Usage: {0} [N]
#
# Author: Latyshev Grigorii
# Date: 29.06.2015
#

import argparse
import logging
import datetime

from .connection import oradbh
from .runchecker import checkRun


class RunListProducer:
  def __init__(self, ndays=None, nrange=None, nocheck=True, regexp=None, policy="and", filterstr=""):
    self.ndays = ndays
    self.nrange = nrange
    self.nocheck = nocheck
    self.filterstr = filterstr
    if 'and' == policy.lower():
      self.policy = "and"
    elif 'or' == policy.lower():
      self.policy = "or"
    elif "not" == policy.lower():
      self.policy = "not"
    else:
      self.policy = None

  def getrunslist(self):
    oradb = oradbh
    if self.ndays and self.nrange:
      if not self.policy:
        logging.error("# Wrong policy selected. Use 'and', 'or', 'not'")
        return [], {}
      logging.info("'{0}' policy will be used".format(self.policy.upper()))
      Pd = RunListProducer(ndays=self.ndays, nocheck=self.nocheck)
      Pr = RunListProducer(nrange=self.nrange, nocheck=self.nocheck)
      sd = Pd.getrunslist()
      sr = Pr.getrunslist()
      mergeddict = {}
      if self.policy == 'and':
        mergedruns = sorted(set(sd[0]).intersection(set(sr[0])))
        for i in set(sd[1].keys()).intersection(set(sr[1].keys())):
          if i in sd[1]:
            mergeddict.update(sd[1])
          else:
            mergeddict.update(sr[1])
      elif self.policy == 'not':
        mergedruns = sorted(set(sd[0]) - set(sr[0]))
        mergeddict.update(sd[1])
        mergeddict.update(sr[1])
        for i in set(sd[1].keys()).intersection(set(sr[1].keys())):
          del mergeddict[i]
      elif self.policy == 'or':
        mergedruns = sorted(set(sd[0]).union(set(sr[0])))
        mergeddict.update(sd[1])
        mergeddict.update(sr[1])
      else:
        return
      return mergedruns, mergeddict
    if not self.nrange and not self.ndays:
      raise RuntimeError("You must set ndays or nrange")
    if self.ndays is not None:
      sql = "select runnumber from CMS_WBM.RUNSUMMARY where STOPTIME >= SYSDATE - {0} and stoptime <= SYSDATE and ecal_present = 1".format(
        self.ndays)
    elif self.nrange is not None:
      sql = "select runnumber from CMS_WBM.RUNSUMMARY where RUNNUMBER >= {0} and RUNNUMBER <=  {1} and ecal_present = 1".format(
        min(self.nrange), max(self.nrange))
    else:
      return
    runnums = [int(x[0]) for x in oradb.cursor().execute(sql)]
    runnums = sorted(runnums)
    rundict = {}
    # check quality of runs
    for r in runnums:
      if not self.nocheck:
        try:
          res = (checkRun(r, self.filterstr), "")
        except:
          res = (False, "Error in checkRun")
      else:
        res = (True, "Checking disabled")
      # checkRun returns (status = True/False, reason = string)
      rundict.update({r: (res[0], res[1])})
    return sorted([int(x) for x in runnums if rundict[x][0]]), rundict


def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('-d', '--days', help="Get list of runs for last N days", action="store", default=None,
    dest='ndays', type=int)
  parser.add_argument('-N', '--no-check', help="Don't check runs quality", action="store_true", default=False,
    dest='nocheck')
  parser.add_argument('-f', '--filter', help="Filter expression", action="store",
    default="Entries > 9000:processedEvents > 9000", dest='filterstr')
  parser.add_argument('-r', '--range', help="Get runs in given range", action="store", default=None, dest='range')
  parser.add_argument('-e', '--expression', help="Regular expression for file name", action="store", default=None,
    dest='regexp')
  parser.add_argument('-v', '--verbose', help="Print skipped runs (sense only for 'check' mode)", action="store_true",
    default=False, dest='verbose')
  parser.add_argument('-p', '--policy', help="AND | OR | NOT rule if -d and -r are both specified", action="store",
    default="and", dest='policy')
  args = parser.parse_args()

  nrange = None
  if not args.range is None:
    start = min([int(x) for x in args.range.split('-')])
    end = max([int(x) for x in args.range.split('-')])
    nrange = (start, end)

  P = RunListProducer(nrange=nrange, ndays=args.ndays, nocheck=args.nocheck, policy=args.policy,
    filterstr=args.filterstr)

  header = "# Generated by getrunlist.py on {0} \n".format(str(datetime.datetime.now()))
  print(header)
  # if status == False -- comment line and print reason else just print run number
  (runnums, rundict) = P.getrunslist()
  for run in sorted(rundict.keys()):
    txt = ""
    if args.verbose and (not rundict[run][0]):
      txt = "# {0} # {1}".format(run, rundict[run][1])
    if rundict[run][0]:
      txt = str(run)
    if txt != "":
      print(txt)


if __name__ == "__main__":
  main()
